/**
 * Apps Script를 사용하여 생성된 RSS XML을 GitHub 레포지토리(GitHub Pages)로 푸시하는 함수입니다.
 * 이 함수는 GitHub Personal Access Token과 레포지토리 정보가 필요합니다.
 */

// === [필수 설정] 아래 변수들은 이제 PropertiesService를 통해 저장/로딩됩니다. ===
// 파일 이름만 코드로 남겨둡니다. (나머지 GITHUB_TOKEN, OWNER, REPO는 PropertiesService에 저장됩니다.)
const FILE_PATH = 'rss.xml'; // GitHub에 저장할 파일 경로 및 이름 (예: 'index.xml' 또는 'rss.xml')
// ========================================================


/**
 * [STEP 1: 최초 1회 실행 필수] 
 * GitHub 토큰 및 설정을 Apps Script의 보안 저장소(Properties Service)에 저장합니다.
 * 토큰이 이미 저장되었다면 이 함수는 더 이상 실행할 필요가 없으며, 보안을 위해 GITHUB_TOKEN 값은 빈 문자열로 변경했습니다.
 */
function setGitHubProperties() {
  const scriptProperties = PropertiesService.getScriptProperties();

  // !!! 주의 !!! 이 함수를 실행한 후에는 이 아래의 GITHUB_TOKEN 값을 지워도 됩니다.
  // 토큰을 이미 저장했다면, 보안을 위해 GITHUB_TOKEN 값은 빈 문자열로 변경하거나, 이 함수 전체를 주석 처리하세요.
  scriptProperties.setProperties({
    'GITHUB_TOKEN': '', // 토큰이 저장되면 이 값을 비워야 보안 경고가 사라집니다.
    'OWNER': 'saferskorea-beep',
    'REPO': 'sebangrss'
  });
  
  Logger.log('GitHub Configuration properties saved securely.');
}


/**
 * [기존 Apps Script의 XML 생성 로직을 통합합니다.]
 * RSS 2.0 규격에 맞는 XML 문자열을 생성하여 반환합니다.
 */
function generateRSSXml() {
  const lastBuildDate = Utilities.formatDate(new Date(), "GMT+9", "EEE, dd MMM yyyy HH:mm:ss Z");

  // 실제 데이터 소스(예: Google Sheet)에서 데이터를 가져오는 로직이 필요합니다.
  const items = [
    { title: "새 소식 3", link: "https://example.com/post3", description: "세 번째 게시물 요약입니다.", category: "OM", pubDate: lastBuildDate },
    { title: "새 소식 2", link: "https://example.com/post2", description: "두 번째 게시물 요약입니다.", category: "LM", pubDate: lastBuildDate },
    { title: "새 소식 1", link: "https://example.com/post1", description: "첫 번째 게시물 요약입니다.", category: "SH", pubDate: lastBuildDate }
  ];

  let itemsXml = items.map(item => `
    <item>
      <title>${escapeXml(item.title)}</title>
      <link>${escapeXml(item.link)}</link>
      <description><![CDATA[${item.description}]]></description>
      <category>${escapeXml(item.category)}</category>
      <pubDate>${item.pubDate}</pubDate>
      <guid isPermaLink="false">${escapeXml(item.link)}#${Utilities.getUuid()}</guid>
    </item>`).join('');

  const xmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>Company Feed - All</title>
    <link>https://example.com</link>
    <description>SH/LM/OM RSS</description>
    <language>ko-KR</language>
    <lastBuildDate>${lastBuildDate}</lastBuildDate>
    ${itemsXml}
  </channel>
</rss>`;

  return xmlContent;
}

/**
 * XML 문자열 내의 특수 문자를 이스케이프 처리합니다.
 */
function escapeXml(unsafe) {
  return unsafe.replace(/[<>&'"]/g, function (c) {
    switch (c) {
      case '<': return '&lt;';
      case '>': return '&gt;';
      case '&': return '&amp;';
      case "'": return '&apos;';
      case '"': return '&quot;';
    }
  });
}

/**
 * GitHub API 통신에 필요한 인증 정보를 PropertiesService에서 가져와 반환합니다.
 */
function getAuthProps() {
    const props = PropertiesService.getScriptProperties();
    return {
        TOKEN: props.getProperty('GITHUB_TOKEN'),
        OWNER: props.getProperty('OWNER'),
        REPO: props.getProperty('REPO')
    };
}


/**
 * GitHub API를 사용하여 파일의 SHA를 가져옵니다.
 * 파일이 존재하지 않으면 null을 반환합니다.
 */
function getFileSha() {
  const auth = getAuthProps();
  if (!auth.TOKEN || !auth.OWNER || !auth.REPO) {
      Logger.log('ERROR: Authentication properties not set. Run setGitHubProperties() first.');
      return null;
  }
  
  const url = `https://api.github.com/repos/${auth.OWNER}/${auth.REPO}/contents/${FILE_PATH}`;
  const response = UrlFetchApp.fetch(url, {
    method: 'GET',
    headers: {
      'Authorization': `token ${auth.TOKEN}`,
      'Accept': 'application/vnd.github.v3+json',
      'User-Agent': 'GoogleAppsScript' // GitHub API 요구사항
    },
    muteHttpExceptions: true
  });

  if (response.getResponseCode() === 200) {
    const content = JSON.parse(response.getContentText());
    Logger.log('Existing file SHA found.');
    return content.sha;
  }
  Logger.log('File does not exist or fetch failed (will create new file). Status: ' + response.getResponseCode());
  return null; // 파일이 없으면 SHA 없음
}


/**
 * 생성된 RSS XML을 GitHub 레포지토리의 FILE_PATH에 푸시(업데이트 또는 생성)합니다.
 * 이 함수를 시간 기반 트리거로 설정해야 합니다.
 */
function updateGitHubRSS() {
  const auth = getAuthProps();
  if (!auth.TOKEN || !auth.OWNER || !auth.REPO) {
      Logger.log('FAILURE: Authentication properties missing. Cannot push to GitHub.');
      return;
  }
  
  const xmlContent = generateRSSXml();
  const base64Content = Utilities.base64Encode(xmlContent, Utilities.Charset.UTF_8);

  const sha = getFileSha(); // 파일의 현재 SHA를 가져와 업데이트 요청에 사용
  
  const apiUrl = `https://api.github.com/repos/${auth.OWNER}/${auth.REPO}/contents/${FILE_PATH}`;
  
  const payload = {
    message: sha ? `Update RSS feed via Apps Script` : `Create initial RSS feed via Apps Script`,
    content: base64Content,
    sha: sha // 파일이 존재하면 SHA를 포함하여 업데이트
  };
  
  const options = {
    method: 'PUT',
    headers: {
      'Authorization': `token ${auth.TOKEN}`,
      'Content-Type': 'application/json',
      'User-Agent': 'GoogleAppsScript' // GitHub API 요구사항
    },
    payload: JSON.stringify(payload),
    muteHttpExceptions: false
  };

  try {
    const response = UrlFetchApp.fetch(apiUrl, options);
    const responseCode = response.getResponseCode();
    
    if (responseCode === 200 || responseCode === 201) {
      Logger.log('Successfully pushed RSS to GitHub: ' + responseCode);
    } else {
      const errorText = response.getContentText();
      Logger.log('GitHub Push FAILED: Code ' + responseCode + ' | Error: ' + errorText);
    }
  } catch (e) {
    Logger.log('API Request FAILED: ' + e.toString());
  }
}
